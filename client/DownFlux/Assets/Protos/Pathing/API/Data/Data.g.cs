// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: pathing/api/data.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace DF.Game.Pathing.API.Data {

  /// <summary>Holder for reflection information generated from pathing/api/data.proto</summary>
  public static partial class DataReflection {

    #region Descriptor
    /// <summary>File descriptor for pathing/api/data.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static DataReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZwYXRoaW5nL2FwaS9kYXRhLnByb3RvEhVnYW1lLnBhdGhpbmcuYXBpLmRh",
            "dGEaDmFwaS9kYXRhLnByb3RvGhtwYXRoaW5nL2FwaS9jb25zdGFudHMucHJv",
            "dG8idgoKQ2x1c3Rlck1hcBIxCg50aWxlX2RpbWVuc2lvbhgBIAEoCzIZLmdh",
            "bWUuYXBpLmRhdGEuQ29vcmRpbmF0ZRI1ChJ0aWxlX21hcF9kaW1lbnNpb24Y",
            "AiABKAsyGS5nYW1lLmFwaS5kYXRhLkNvb3JkaW5hdGUisAEKDUFic3RyYWN0",
            "R3JhcGgSNwoMY2x1c3Rlcl9tYXBzGAEgAygLMiEuZ2FtZS5wYXRoaW5nLmFw",
            "aS5kYXRhLkNsdXN0ZXJNYXASMgoFbm9kZXMYAiADKAsyIy5nYW1lLnBhdGhp",
            "bmcuYXBpLmRhdGEuQWJzdHJhY3ROb2RlEjIKBWVkZ2VzGAMgAygLMiMuZ2Ft",
            "ZS5wYXRoaW5nLmFwaS5kYXRhLkFic3RyYWN0RWRnZSLeAQoMQWJzdHJhY3RO",
            "b2RlEhQKDGlzX2VwaGVtZXJhbBgBIAEoCBJOCg5lcGhlbWVyYWxfa2V5cxgC",
            "IAMoCzI2LmdhbWUucGF0aGluZy5hcGkuZGF0YS5BYnN0cmFjdE5vZGUuRXBo",
            "ZW1lcmFsS2V5c0VudHJ5EjIKD3RpbGVfY29vcmRpbmF0ZRgDIAEoCzIZLmdh",
            "bWUuYXBpLmRhdGEuQ29vcmRpbmF0ZRo0ChJFcGhlbWVyYWxLZXlzRW50cnkS",
            "CwoDa2V5GAEgASgDEg0KBXZhbHVlGAIgASgIOgI4ASKyAQoMQWJzdHJhY3RF",
            "ZGdlEikKBnNvdXJjZRgBIAEoCzIZLmdhbWUuYXBpLmRhdGEuQ29vcmRpbmF0",
            "ZRIuCgtkZXN0aW5hdGlvbhgCIAEoCzIZLmdhbWUuYXBpLmRhdGEuQ29vcmRp",
            "bmF0ZRI3CgllZGdlX3R5cGUYAyABKA4yJC5nYW1lLnBhdGhpbmcuYXBpLmNv",
            "bnN0YW50cy5FZGdlVHlwZRIOCgZ3ZWlnaHQYBCABKAFCMloVZ2FtZS5wYXRo",
            "aW5nLmFwaS5kYXRhqgIYREYuR2FtZS5QYXRoaW5nLkFQSS5EYXRhYgZwcm90",
            "bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::DF.Game.API.Data.DataReflection.Descriptor, global::DF.Game.Pathing.API.Constants.ConstantsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::DF.Game.Pathing.API.Data.ClusterMap), global::DF.Game.Pathing.API.Data.ClusterMap.Parser, new[]{ "TileDimension", "TileMapDimension" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::DF.Game.Pathing.API.Data.AbstractGraph), global::DF.Game.Pathing.API.Data.AbstractGraph.Parser, new[]{ "ClusterMaps", "Nodes", "Edges" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::DF.Game.Pathing.API.Data.AbstractNode), global::DF.Game.Pathing.API.Data.AbstractNode.Parser, new[]{ "IsEphemeral", "EphemeralKeys", "TileCoordinate" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::DF.Game.Pathing.API.Data.AbstractEdge), global::DF.Game.Pathing.API.Data.AbstractEdge.Parser, new[]{ "Source", "Destination", "EdgeType", "Weight" }, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class ClusterMap : pb::IMessage<ClusterMap>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ClusterMap> _parser = new pb::MessageParser<ClusterMap>(() => new ClusterMap());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ClusterMap> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::DF.Game.Pathing.API.Data.DataReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClusterMap() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClusterMap(ClusterMap other) : this() {
      tileDimension_ = other.tileDimension_ != null ? other.tileDimension_.Clone() : null;
      tileMapDimension_ = other.tileMapDimension_ != null ? other.tileMapDimension_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClusterMap Clone() {
      return new ClusterMap(this);
    }

    /// <summary>Field number for the "tile_dimension" field.</summary>
    public const int TileDimensionFieldNumber = 1;
    private global::DF.Game.API.Data.Coordinate tileDimension_;
    /// <summary>
    /// Base dimension per cluster.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::DF.Game.API.Data.Coordinate TileDimension {
      get { return tileDimension_; }
      set {
        tileDimension_ = value;
      }
    }

    /// <summary>Field number for the "tile_map_dimension" field.</summary>
    public const int TileMapDimensionFieldNumber = 2;
    private global::DF.Game.API.Data.Coordinate tileMapDimension_;
    /// <summary>
    /// Underlying TileMap dimension.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::DF.Game.API.Data.Coordinate TileMapDimension {
      get { return tileMapDimension_; }
      set {
        tileMapDimension_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ClusterMap);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ClusterMap other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TileDimension, other.TileDimension)) return false;
      if (!object.Equals(TileMapDimension, other.TileMapDimension)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (tileDimension_ != null) hash ^= TileDimension.GetHashCode();
      if (tileMapDimension_ != null) hash ^= TileMapDimension.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (tileDimension_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TileDimension);
      }
      if (tileMapDimension_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TileMapDimension);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (tileDimension_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(TileDimension);
      }
      if (tileMapDimension_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(TileMapDimension);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (tileDimension_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TileDimension);
      }
      if (tileMapDimension_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TileMapDimension);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ClusterMap other) {
      if (other == null) {
        return;
      }
      if (other.tileDimension_ != null) {
        if (tileDimension_ == null) {
          TileDimension = new global::DF.Game.API.Data.Coordinate();
        }
        TileDimension.MergeFrom(other.TileDimension);
      }
      if (other.tileMapDimension_ != null) {
        if (tileMapDimension_ == null) {
          TileMapDimension = new global::DF.Game.API.Data.Coordinate();
        }
        TileMapDimension.MergeFrom(other.TileMapDimension);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (tileDimension_ == null) {
              TileDimension = new global::DF.Game.API.Data.Coordinate();
            }
            input.ReadMessage(TileDimension);
            break;
          }
          case 18: {
            if (tileMapDimension_ == null) {
              TileMapDimension = new global::DF.Game.API.Data.Coordinate();
            }
            input.ReadMessage(TileMapDimension);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (tileDimension_ == null) {
              TileDimension = new global::DF.Game.API.Data.Coordinate();
            }
            input.ReadMessage(TileDimension);
            break;
          }
          case 18: {
            if (tileMapDimension_ == null) {
              TileMapDimension = new global::DF.Game.API.Data.Coordinate();
            }
            input.ReadMessage(TileMapDimension);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AbstractGraph : pb::IMessage<AbstractGraph>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AbstractGraph> _parser = new pb::MessageParser<AbstractGraph>(() => new AbstractGraph());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AbstractGraph> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::DF.Game.Pathing.API.Data.DataReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AbstractGraph() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AbstractGraph(AbstractGraph other) : this() {
      clusterMaps_ = other.clusterMaps_.Clone();
      nodes_ = other.nodes_.Clone();
      edges_ = other.edges_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AbstractGraph Clone() {
      return new AbstractGraph(this);
    }

    /// <summary>Field number for the "cluster_maps" field.</summary>
    public const int ClusterMapsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::DF.Game.Pathing.API.Data.ClusterMap> _repeated_clusterMaps_codec
        = pb::FieldCodec.ForMessage(10, global::DF.Game.Pathing.API.Data.ClusterMap.Parser);
    private readonly pbc::RepeatedField<global::DF.Game.Pathing.API.Data.ClusterMap> clusterMaps_ = new pbc::RepeatedField<global::DF.Game.Pathing.API.Data.ClusterMap>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::DF.Game.Pathing.API.Data.ClusterMap> ClusterMaps {
      get { return clusterMaps_; }
    }

    /// <summary>Field number for the "nodes" field.</summary>
    public const int NodesFieldNumber = 2;
    private static readonly pb::FieldCodec<global::DF.Game.Pathing.API.Data.AbstractNode> _repeated_nodes_codec
        = pb::FieldCodec.ForMessage(18, global::DF.Game.Pathing.API.Data.AbstractNode.Parser);
    private readonly pbc::RepeatedField<global::DF.Game.Pathing.API.Data.AbstractNode> nodes_ = new pbc::RepeatedField<global::DF.Game.Pathing.API.Data.AbstractNode>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::DF.Game.Pathing.API.Data.AbstractNode> Nodes {
      get { return nodes_; }
    }

    /// <summary>Field number for the "edges" field.</summary>
    public const int EdgesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::DF.Game.Pathing.API.Data.AbstractEdge> _repeated_edges_codec
        = pb::FieldCodec.ForMessage(26, global::DF.Game.Pathing.API.Data.AbstractEdge.Parser);
    private readonly pbc::RepeatedField<global::DF.Game.Pathing.API.Data.AbstractEdge> edges_ = new pbc::RepeatedField<global::DF.Game.Pathing.API.Data.AbstractEdge>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::DF.Game.Pathing.API.Data.AbstractEdge> Edges {
      get { return edges_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AbstractGraph);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AbstractGraph other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!clusterMaps_.Equals(other.clusterMaps_)) return false;
      if(!nodes_.Equals(other.nodes_)) return false;
      if(!edges_.Equals(other.edges_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= clusterMaps_.GetHashCode();
      hash ^= nodes_.GetHashCode();
      hash ^= edges_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      clusterMaps_.WriteTo(output, _repeated_clusterMaps_codec);
      nodes_.WriteTo(output, _repeated_nodes_codec);
      edges_.WriteTo(output, _repeated_edges_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      clusterMaps_.WriteTo(ref output, _repeated_clusterMaps_codec);
      nodes_.WriteTo(ref output, _repeated_nodes_codec);
      edges_.WriteTo(ref output, _repeated_edges_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += clusterMaps_.CalculateSize(_repeated_clusterMaps_codec);
      size += nodes_.CalculateSize(_repeated_nodes_codec);
      size += edges_.CalculateSize(_repeated_edges_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AbstractGraph other) {
      if (other == null) {
        return;
      }
      clusterMaps_.Add(other.clusterMaps_);
      nodes_.Add(other.nodes_);
      edges_.Add(other.edges_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            clusterMaps_.AddEntriesFrom(input, _repeated_clusterMaps_codec);
            break;
          }
          case 18: {
            nodes_.AddEntriesFrom(input, _repeated_nodes_codec);
            break;
          }
          case 26: {
            edges_.AddEntriesFrom(input, _repeated_edges_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            clusterMaps_.AddEntriesFrom(ref input, _repeated_clusterMaps_codec);
            break;
          }
          case 18: {
            nodes_.AddEntriesFrom(ref input, _repeated_nodes_codec);
            break;
          }
          case 26: {
            edges_.AddEntriesFrom(ref input, _repeated_edges_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AbstractNode : pb::IMessage<AbstractNode>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AbstractNode> _parser = new pb::MessageParser<AbstractNode>(() => new AbstractNode());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AbstractNode> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::DF.Game.Pathing.API.Data.DataReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AbstractNode() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AbstractNode(AbstractNode other) : this() {
      isEphemeral_ = other.isEphemeral_;
      ephemeralKeys_ = other.ephemeralKeys_.Clone();
      tileCoordinate_ = other.tileCoordinate_ != null ? other.tileCoordinate_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AbstractNode Clone() {
      return new AbstractNode(this);
    }

    /// <summary>Field number for the "is_ephemeral" field.</summary>
    public const int IsEphemeralFieldNumber = 1;
    private bool isEphemeral_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsEphemeral {
      get { return isEphemeral_; }
      set {
        isEphemeral_ = value;
      }
    }

    /// <summary>Field number for the "ephemeral_keys" field.</summary>
    public const int EphemeralKeysFieldNumber = 2;
    private static readonly pbc::MapField<long, bool>.Codec _map_ephemeralKeys_codec
        = new pbc::MapField<long, bool>.Codec(pb::FieldCodec.ForInt64(8, 0L), pb::FieldCodec.ForBool(16, false), 18);
    private readonly pbc::MapField<long, bool> ephemeralKeys_ = new pbc::MapField<long, bool>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<long, bool> EphemeralKeys {
      get { return ephemeralKeys_; }
    }

    /// <summary>Field number for the "tile_coordinate" field.</summary>
    public const int TileCoordinateFieldNumber = 3;
    private global::DF.Game.API.Data.Coordinate tileCoordinate_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::DF.Game.API.Data.Coordinate TileCoordinate {
      get { return tileCoordinate_; }
      set {
        tileCoordinate_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AbstractNode);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AbstractNode other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IsEphemeral != other.IsEphemeral) return false;
      if (!EphemeralKeys.Equals(other.EphemeralKeys)) return false;
      if (!object.Equals(TileCoordinate, other.TileCoordinate)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (IsEphemeral != false) hash ^= IsEphemeral.GetHashCode();
      hash ^= EphemeralKeys.GetHashCode();
      if (tileCoordinate_ != null) hash ^= TileCoordinate.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (IsEphemeral != false) {
        output.WriteRawTag(8);
        output.WriteBool(IsEphemeral);
      }
      ephemeralKeys_.WriteTo(output, _map_ephemeralKeys_codec);
      if (tileCoordinate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TileCoordinate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (IsEphemeral != false) {
        output.WriteRawTag(8);
        output.WriteBool(IsEphemeral);
      }
      ephemeralKeys_.WriteTo(ref output, _map_ephemeralKeys_codec);
      if (tileCoordinate_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(TileCoordinate);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (IsEphemeral != false) {
        size += 1 + 1;
      }
      size += ephemeralKeys_.CalculateSize(_map_ephemeralKeys_codec);
      if (tileCoordinate_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TileCoordinate);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AbstractNode other) {
      if (other == null) {
        return;
      }
      if (other.IsEphemeral != false) {
        IsEphemeral = other.IsEphemeral;
      }
      ephemeralKeys_.Add(other.ephemeralKeys_);
      if (other.tileCoordinate_ != null) {
        if (tileCoordinate_ == null) {
          TileCoordinate = new global::DF.Game.API.Data.Coordinate();
        }
        TileCoordinate.MergeFrom(other.TileCoordinate);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            IsEphemeral = input.ReadBool();
            break;
          }
          case 18: {
            ephemeralKeys_.AddEntriesFrom(input, _map_ephemeralKeys_codec);
            break;
          }
          case 26: {
            if (tileCoordinate_ == null) {
              TileCoordinate = new global::DF.Game.API.Data.Coordinate();
            }
            input.ReadMessage(TileCoordinate);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 8: {
            IsEphemeral = input.ReadBool();
            break;
          }
          case 18: {
            ephemeralKeys_.AddEntriesFrom(ref input, _map_ephemeralKeys_codec);
            break;
          }
          case 26: {
            if (tileCoordinate_ == null) {
              TileCoordinate = new global::DF.Game.API.Data.Coordinate();
            }
            input.ReadMessage(TileCoordinate);
            break;
          }
        }
      }
    }
    #endif

  }

  public sealed partial class AbstractEdge : pb::IMessage<AbstractEdge>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<AbstractEdge> _parser = new pb::MessageParser<AbstractEdge>(() => new AbstractEdge());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AbstractEdge> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::DF.Game.Pathing.API.Data.DataReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AbstractEdge() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AbstractEdge(AbstractEdge other) : this() {
      source_ = other.source_ != null ? other.source_.Clone() : null;
      destination_ = other.destination_ != null ? other.destination_.Clone() : null;
      edgeType_ = other.edgeType_;
      weight_ = other.weight_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AbstractEdge Clone() {
      return new AbstractEdge(this);
    }

    /// <summary>Field number for the "source" field.</summary>
    public const int SourceFieldNumber = 1;
    private global::DF.Game.API.Data.Coordinate source_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::DF.Game.API.Data.Coordinate Source {
      get { return source_; }
      set {
        source_ = value;
      }
    }

    /// <summary>Field number for the "destination" field.</summary>
    public const int DestinationFieldNumber = 2;
    private global::DF.Game.API.Data.Coordinate destination_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::DF.Game.API.Data.Coordinate Destination {
      get { return destination_; }
      set {
        destination_ = value;
      }
    }

    /// <summary>Field number for the "edge_type" field.</summary>
    public const int EdgeTypeFieldNumber = 3;
    private global::DF.Game.Pathing.API.Constants.EdgeType edgeType_ = global::DF.Game.Pathing.API.Constants.EdgeType.Unknown;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::DF.Game.Pathing.API.Constants.EdgeType EdgeType {
      get { return edgeType_; }
      set {
        edgeType_ = value;
      }
    }

    /// <summary>Field number for the "weight" field.</summary>
    public const int WeightFieldNumber = 4;
    private double weight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public double Weight {
      get { return weight_; }
      set {
        weight_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AbstractEdge);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AbstractEdge other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Source, other.Source)) return false;
      if (!object.Equals(Destination, other.Destination)) return false;
      if (EdgeType != other.EdgeType) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Weight, other.Weight)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (source_ != null) hash ^= Source.GetHashCode();
      if (destination_ != null) hash ^= Destination.GetHashCode();
      if (EdgeType != global::DF.Game.Pathing.API.Constants.EdgeType.Unknown) hash ^= EdgeType.GetHashCode();
      if (Weight != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Weight);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (source_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Source);
      }
      if (destination_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Destination);
      }
      if (EdgeType != global::DF.Game.Pathing.API.Constants.EdgeType.Unknown) {
        output.WriteRawTag(24);
        output.WriteEnum((int) EdgeType);
      }
      if (Weight != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(Weight);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (source_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Source);
      }
      if (destination_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Destination);
      }
      if (EdgeType != global::DF.Game.Pathing.API.Constants.EdgeType.Unknown) {
        output.WriteRawTag(24);
        output.WriteEnum((int) EdgeType);
      }
      if (Weight != 0D) {
        output.WriteRawTag(33);
        output.WriteDouble(Weight);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (source_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Source);
      }
      if (destination_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Destination);
      }
      if (EdgeType != global::DF.Game.Pathing.API.Constants.EdgeType.Unknown) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) EdgeType);
      }
      if (Weight != 0D) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AbstractEdge other) {
      if (other == null) {
        return;
      }
      if (other.source_ != null) {
        if (source_ == null) {
          Source = new global::DF.Game.API.Data.Coordinate();
        }
        Source.MergeFrom(other.Source);
      }
      if (other.destination_ != null) {
        if (destination_ == null) {
          Destination = new global::DF.Game.API.Data.Coordinate();
        }
        Destination.MergeFrom(other.Destination);
      }
      if (other.EdgeType != global::DF.Game.Pathing.API.Constants.EdgeType.Unknown) {
        EdgeType = other.EdgeType;
      }
      if (other.Weight != 0D) {
        Weight = other.Weight;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (source_ == null) {
              Source = new global::DF.Game.API.Data.Coordinate();
            }
            input.ReadMessage(Source);
            break;
          }
          case 18: {
            if (destination_ == null) {
              Destination = new global::DF.Game.API.Data.Coordinate();
            }
            input.ReadMessage(Destination);
            break;
          }
          case 24: {
            EdgeType = (global::DF.Game.Pathing.API.Constants.EdgeType) input.ReadEnum();
            break;
          }
          case 33: {
            Weight = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (source_ == null) {
              Source = new global::DF.Game.API.Data.Coordinate();
            }
            input.ReadMessage(Source);
            break;
          }
          case 18: {
            if (destination_ == null) {
              Destination = new global::DF.Game.API.Data.Coordinate();
            }
            input.ReadMessage(Destination);
            break;
          }
          case 24: {
            EdgeType = (global::DF.Game.Pathing.API.Constants.EdgeType) input.ReadEnum();
            break;
          }
          case 33: {
            Weight = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
